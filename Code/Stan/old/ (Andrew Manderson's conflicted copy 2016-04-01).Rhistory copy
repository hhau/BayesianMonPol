5*exp(-(1+2))
5*exp(-(2-1))
5*exp(-(3-1))
5*exp(-(4-1))
5*exp(-(5-1))
4*exp(-(1-1)) + 1
4*exp(-(2-1)) + 1
4*exp(-(3-1)) + 1
4*exp(-(4-1)) + 1
4*exp(-(5-1)) + 1
4*exp(-(6-1)) + 1
4*exp(-(7-1)) + 1
4*exp(-(8-1)) + 1
rstan:::rstudio_stanc("Desktop/aam/roundfits/01/Skellam goal and behind difference.stan")
100/(7500*4)
rm(llist = ls())
rm(list = ls())
t <- 1:7
(5-1) * exp(-(t-1)) + 1
help("round")
round((5-1) * exp(-(t-1)) + 1, 2)
library(htmltools)
library(rvest)
Sys.which("pdflatex")
acf(x.1.values)
plot(x = lambda.vec, y = post , ylim = c(0,3))
y.vec <- c(8,3,4,3,1,7,2,6,2,7) #
# firstly, lets hammer in on what this density looks like
# define the necessary constants
mu <- log(4)
sigma <- 1/(sqrt(2))
sum.y <- sum(y.vec)
prod.of.factorials.y <- prod(factorial(y.vec))
lambda.vec <- (1:800)/100
n <- length(y.vec)
left <- lambda.vec^(sum.y) * exp(-n * lambda.vec) / (prod.of.factorials.y)
middle <- 1 / (lambda.vec * sigma * sqrt(2*pi))
right <- exp(-(1/(2*sigma^2)) * (log(lambda.vec) - mu)^2)
post <- left * middle * right
plot(x = lambda.vec, y = post , ylim = c(0,3))
plot(x = lambda.vec, y = post )
plot(x = lambda.vec, y = post , ylim = c(0, 2e-11))
plot(x = lambda.vec, y = post , ylim = c(0, 3e-11))
curve(M* dgamma(x,shape = 4.78 , rate = 1.04), 0, 10)
M <- 1e-10
curve(M* dgamma(x,shape = 4.78 , rate = 1.04), 0, 10)
plot(x = lambda.vec, y = post , ylim = c(0, 3e-11))
lines(M* dgamma(x,shape = 4.78 , rate = 1.04), 0, 10)
lines(M* dgamma( lambda.vec ,shape = 4.78 , rate = 1.04), 0, 10)
lines(x = lambda.vec, y = M* dgamma( lambda.vec ,shape = 4.78 , rate = 1.04), 0, 10)
lines(x = lambda.vec, y = M* dgamma( lambda.vec ,shape = 4.78 , rate = 1.04))
plot(x = lambda.vec, y = post , ylim = c(0, 3e-11), type = "l")
lines(x = lambda.vec, y = M* dgamma( lambda.vec ,shape = 4.78 , rate = 1.04), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 4.78 , rate = 1.05), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 4.78 , rate = 1.45), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 4.78 , rate = 1.25), col = "red")
plot(x = lambda.vec, y = post , ylim = c(0, 3e-11), type = "l")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 4.78 , rate = 1.05), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 6.78 , rate = 1.05), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 6.78 , rate = 2.05), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 8.78 , rate = 2.05), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 9.78 , rate = 2.05), col = "red")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
plot(x = lambda.vec, y = post , ylim = c(0, 3e-11), type = "l")
lines(x = lambda.vec, y = M* dgamma( lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
lines(x = lambda.vec, y = M * dgamma( lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
M <- 5e-9
lines(x = lambda.vec, y = M * dgamma(lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
M <- 5e-11
lines(x = lambda.vec, y = M * dgamma(lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
M <- 7e-11
lines(x = lambda.vec, y = M * dgamma(lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
plot(x = lambda.vec, y = post , ylim = c(0, 3e-11), type = "l")
lines(x = lambda.vec, y = M * dgamma(lambda.vec , shape = 9.38 , rate = 2.05), col = "red")
samples <- 0
accept <- 0
i <- 1
while (i < 100000) {
X <- rgamma(1, shape = 4.78, rate = 1.04)
ratio <- post.den(X) / (M * dgamma(X, shape = 9.38, rate = 2.05))
if(runif(1) < ratio) {
samples <- c(samples, X)
accept <- accept + 1
}
i <- i + 1
}
post.den <- function(x) {
left <- x^(sum.y) * exp(-n * x) / (prod.of.factorials.y)
middle <- 1 / (x * sigma * sqrt(2*pi))
right <- exp(-(1/(2*sigma^2)) * (log(x) - mu)^2)
return(left * middle * right)
}
samples <- 0
accept <- 0
i <- 1
while (i < 100000) {
X <- rgamma(1, shape = 4.78, rate = 1.04)
ratio <- post.den(X) / (M * dgamma(X, shape = 9.38, rate = 2.05))
if(runif(1) < ratio) {
samples <- c(samples, X)
accept <- accept + 1
}
i <- i + 1
}
samples <- samples[-1]
hist(samples, breaks = 30, freq = FALSE, ylim = c(0,1))
den.e <- density(samples)
lines(den.e$x, den.e$y)
accept / 100000 # acceptance rate of 20~25%, could improve by decreasing M
library(CITAN)
1-(0.9^50)
install.packages(c("BH", "car", "CITAN", "digest", "effects", "ggplot2", "Hmisc", "htmltools", "jsonlite", "knitr", "Matrix", "mgcv", "pbkrtest", "Rcpp", "rgl", "rjags", "rJava", "rmarkdown", "Rmpfr", "rstan", "rstudioapi", "StanHeaders", "visNetwork"))
x <- c()
x[1] <- 1
x[2] <- 1
for(i in 3:1000){
x[i] <- x[i-1] + x[i-2]
}
x
fib.func <- function(i) {
if(i == 1 ){
return(1)
break
} else if (i == 2) {
return(1)
}  else {
return( (fib.func(i-1) + fib.func(i-2)) )
}
fib.func(i-1)
}
fib.func(4)
fib.func(10)
View(fib.func)
new.word <- input[-1] + input + input[1] + "ay"
input <- "tempstr"
new.word <- input[-1] + input + input[1] + "ay"
input
input[1]
input <- as.array("tempstr")
input
input[-1]
new.word <- input[-1] + input + input[1] + "ay"
input[1]
new.word <- substr(input, 2, length(input))
new.word
input <- as.array("tempstr")
new.word <- substr(input, 2, length(input))
newor.d
new.word
substr(input, 2, length(input))
new.word <- substr(input, 1, 1)
new.word
new.word <- substr(input, 2, 4)
new.word
length(input)
new.word <- substr(input, 2, nchar(input))
new.word
new.word <- substr(input, 2, nchar(input)) + substr(input,1,1) + "ay"
substr(input, 2, nchar(input))
new.word <- c(substr(input, 2, nchar(input)), substr(input,1,1), "ay")
new.owrd
new.word
new.word <- paste(substr(input, 2, nchar(input)), substr(input,1,1), "ay")
new.word
new.word <- paste(substr(input, 2, nchar(input)), substr(input,1,1), "ay", sep = "")
new.word
input <- readline(prompt = "Exter a word to translate")
print(input)
input <- readline(prompt = "Exter a word to translate")
new.word <- paste(substr(input, 2, nchar(input)), substr(input,1,1), "ay", sep = "")
input <- readline(prompt = "Exter a word to translate: \n")
new.word <- paste(substr(input, 2, nchar(input)), substr(input,1,1), "ay", sep = "")
print(input)
input
input <- readline(prompt = "Exter a word to translate: \n")
input
new.word <- paste(substr(input, 2, nchar(input)), substr(input,1,1), "ay", sep = "")
new.word
print(input)
input <- readline(prompt = "Exter a word to translate: \n")
print(new.word)
1 + 2 - 3 * 4 / 5 ^ 6 % 7
1 + 2 - 3 * 4 / 5 ^ 6 %% 7
qnorm(0.975)
1.96*0.2
0.5 - 0.392
0.5 + 0.392
2^40
1e7
1e7/1000000
531-18.69
50*0.011 + 0.0289
50*0.0011 + 0.0289
250*0.0011 + 0.0289
p.hit <- 0:100 / 100
p.hit
help(rep)
p.hit.rf <- c(rep.int(0,15), 1:100 / 100)
p.hit.rf
p.rf 1 - (1 - p.hit.rf)^2
p.rf <- 1 - (1 - p.hit.rf)^2
p.rf
plot(x = p.hit, y = p.hit)
points(x = p.rf, y = p.rf)
p.hit.rf <-  1:115 / 115)
p.hit.rf <-  1:115 / 115
p.rf <- 1 - (1 - (p.hit.rf-0.15))^2
p.rf
p.hit.rf <-  1:120 / 120
p.hit <- 0:120 / 120
p.hit.rf <-  1:120 / 120
p.rf <- 1 - (1 - (p.hit.rf-0.15))^2
p.rf
p.hit.rf
p.hit.rf <-  1:120 / 100
p.hit <- 0:120 / 100
p.rf <- 1 - (1 - (p.hit.rf-0.15))^2
p.rf
plot(x = p.hit, y = p.rf)
length)(p.hit)
length(p.jit)
length(p.hit)
length(p.rf)
p.hit.rf <-  0:120 / 100
p.rf <- 1 - (1 - (p.hit.rf-0.15))^2
plot(x = p.hit, y = p.rf)
abline(h = c(0,1))
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
plot(x = p.hit, y = p.rf, xlim = c(0,1), ylim = c(0,1))
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
plot(x = p.hit, y = p.rf, xlim = c(0,1.15), ylim = c(0,1))
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1))
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
p.hit <- 0:115 / 100
p.hit.rf <-  0:115/ 100
p.rf <- 1 - (1 - (p.hit.rf-0.15))^2
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1))
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), lty = "l")
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), type = = "l")
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), type = "l")
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), type = "o")
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), type = "p")
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), type = "l")
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
plot(x = p.hit, y = p.rf, xlim = c(0,1.2), ylim = c(0,1), type = "l", col = "blue")
abline(h = c(0,1), v = c(0,1))
abline(a = 0, b = 1)
help(glm)
help(attack)
help(attach)
x <- seq(from=-1, to=1, length=N)
rm(list = ls())
N <- 41
x <- seq(from=-1, to=1, length=N)
x
x^2
rnorm(x, sd=0.1)
plot(rnorm(x, sd=0.1))
points(x, col = red)
points(x, col = "red")
help(rnorm)
x.values <- seq(from = a.lower, to = b.upper, length = n.data.points)
x <- seq(from=-1, to=1, length=N)
x
1.5 * x
x^2
GeneratePolyData <- function(data.lower, data.upper, poly.order, poly.type, n.data.points, sigma.noise) {
# poly.order corresponds to 0 = intercept only, 1  =  flat line, 2 = quadratic, etc etc
# poly type should take values from 1 - ?
x.values <- seq(from = data.lower, to = data.upper, length = n.data.points)
noise <- rnorm(n.data.points, sd = sigma.noise)
if (poly.order < 1) {
# this is a silly case
print("Don't be silly")
break
} else if (poly.order == 1) {
# this is a straight line with off set (for some reason?)
beta.true <- c(1/4, 1.5)
y.values <- 1/4 + 1.5 * x.values + noise
} else if (poly.order == 2 & poly.type == 1) {
# just x^2
beta.true <- c(0, 0, 1)
y.values <-  x.values^2 + noise
} else if (poly.order == 2 & poly.type == 2) {
# 1/4 + x + x^2
beta.true <- c(1/4, 1, 1)
y.values <- 1/4 + x.values + x.values^2 + noise
} else if (poly.order == 3) {
# the only cubic is just x^3
beta.true <- c(0,0,0,1)
y.values <-  x.values^3 + noise
} else if (poly.order == 4) {
# again only one type of quartic
# x^2 + 2x^4
beta.true <- c(0,0,1,0,2)
y.values <- x.values^2 + 2 * x.values^4 + noise
} else if (poly.order ==  5) {
# only consider x^5
beta.true <- c(0,0,0,0,0,1)
y.values <- x.values^5 + noise
} else if (poly.orer == 6) {
print("tbd")
break
} else if (poly.order == 7) {
# seems like you need more noise for this one, leave up to adjusting sigma
beta.true <- c(0,3,0,2,0,1,0,1)
y.values <- 3 * x.values + 2 * x.values^3 + x.values^5 + x.values^7
} else {
print("Please choose appropriate polynomial order and type (or something else has goofed)")
break
}
output.frame <- data.frame()
output.frame$x.values <- x.values
output.frame$y.values <- y.values
output.frame$beta.true <- beta.true
return(output.frame)
}
simulated.data <- GeneratePolyData(-1, 1, 2, 1, 50, 0.1)
data.lower = -1, data.upper =  1, poly.order = 2, poly.type = 1, n.data.points = 50, sigma.noise = 0.1
data.lower = -1
data.upper =  1
poly.order = 2
poly.type = 1
n.data.points = 50
sigma.noise = 0.1)
sigma.noise = 0.1
x.values <- seq(from = data.lower, to = data.upper, length = n.data.points)
x.values
noise <- rnorm(n.data.points, sd = sigma.noise)
noise
if (poly.order < 1) {
# this is a silly case
print("Don't be silly")
break
} else if (poly.order == 1) {
# this is a straight line with off set (for some reason?)
beta.true <- c(1/4, 1.5)
y.values <- 1/4 + 1.5 * x.values + noise
} else if (poly.order == 2 & poly.type == 1) {
# just x^2
beta.true <- c(0, 0, 1)
y.values <-  x.values^2 + noise
} else if (poly.order == 2 & poly.type == 2) {
# 1/4 + x + x^2
beta.true <- c(1/4, 1, 1)
y.values <- 1/4 + x.values + x.values^2 + noise
} else if (poly.order == 3) {
# the only cubic is just x^3
beta.true <- c(0,0,0,1)
y.values <-  x.values^3 + noise
} else if (poly.order == 4) {
# again only one type of quartic
# x^2 + 2x^4
beta.true <- c(0,0,1,0,2)
y.values <- x.values^2 + 2 * x.values^4 + noise
} else if (poly.order ==  5) {
# only consider x^5
beta.true <- c(0,0,0,0,0,1)
y.values <- x.values^5 + noise
} else if (poly.orer == 6) {
print("tbd")
break
} else if (poly.order == 7) {
# seems like you need more noise for this one, leave up to adjusting sigma
beta.true <- c(0,3,0,2,0,1,0,1)
y.values <- 3 * x.values + 2 * x.values^3 + x.values^5 + x.values^7
} else {
print("Please choose appropriate polynomial order and type (or something else has goofed)")
break
}
poly.order
y.values
plot(x = x.values, y = y.values)
poly.type <- 2
if (poly.order < 1) {
# this is a silly case
print("Don't be silly")
break
} else if (poly.order == 1) {
# this is a straight line with off set (for some reason?)
beta.true <- c(1/4, 1.5)
y.values <- 1/4 + 1.5 * x.values + noise
} else if (poly.order == 2 & poly.type == 1) {
# just x^2
beta.true <- c(0, 0, 1)
y.values <-  x.values^2 + noise
} else if (poly.order == 2 & poly.type == 2) {
# 1/4 + x + x^2
beta.true <- c(1/4, 1, 1)
y.values <- 1/4 + x.values + x.values^2 + noise
} else if (poly.order == 3) {
# the only cubic is just x^3
beta.true <- c(0,0,0,1)
y.values <-  x.values^3 + noise
} else if (poly.order == 4) {
# again only one type of quartic
# x^2 + 2x^4
beta.true <- c(0,0,1,0,2)
y.values <- x.values^2 + 2 * x.values^4 + noise
} else if (poly.order ==  5) {
# only consider x^5
beta.true <- c(0,0,0,0,0,1)
y.values <- x.values^5 + noise
} else if (poly.orer == 6) {
print("tbd")
break
} else if (poly.order == 7) {
# seems like you need more noise for this one, leave up to adjusting sigma
beta.true <- c(0,3,0,2,0,1,0,1)
y.values <- 3 * x.values + 2 * x.values^3 + x.values^5 + x.values^7
} else {
print("Please choose appropriate polynomial order and type (or something else has goofed)")
break
}
plot(x = x.values, y = y.values)
output.frame <- data.frame()
output.frame$x.values <- x.values
data.frame(x.values, y.values)
data.frame(x.values, y.values, beta.true)
list(x.values, y.values, beta.true)
output.list <- list(x.values = x.values, y.values = y.values, beta.true = beta.true)
output.list
GeneratePolyData <- function(data.lower, data.upper, poly.order, poly.type, n.data.points, sigma.noise) {
# poly.order corresponds to 0 = intercept only, 1  =  flat line, 2 = quadratic, etc etc
# poly type should take values from 1 - ?
x.values <- seq(from = data.lower, to = data.upper, length = n.data.points)
noise <- rnorm(n.data.points, sd = sigma.noise)
if (poly.order < 1) {
# this is a silly case
print("Don't be silly")
break
} else if (poly.order == 1) {
# this is a straight line with off set (for some reason?)
beta.true <- c(1/4, 1.5)
y.values <- 1/4 + 1.5 * x.values + noise
} else if (poly.order == 2 & poly.type == 1) {
# just x^2
beta.true <- c(0, 0, 1)
y.values <-  x.values^2 + noise
} else if (poly.order == 2 & poly.type == 2) {
# 1/4 + x + x^2
beta.true <- c(1/4, 1, 1)
y.values <- 1/4 + x.values + x.values^2 + noise
} else if (poly.order == 3) {
# the only cubic is just x^3
beta.true <- c(0,0,0,1)
y.values <-  x.values^3 + noise
} else if (poly.order == 4) {
# again only one type of quartic
# x^2 + 2x^4
beta.true <- c(0,0,1,0,2)
y.values <- x.values^2 + 2 * x.values^4 + noise
} else if (poly.order ==  5) {
# only consider x^5
beta.true <- c(0,0,0,0,0,1)
y.values <- x.values^5 + noise
} else if (poly.orer == 6) {
print("tbd")
break
} else if (poly.order == 7) {
# seems like you need more noise for this one, leave up to adjusting sigma
beta.true <- c(0,3,0,2,0,1,0,1)
y.values <- 3 * x.values + 2 * x.values^3 + x.values^5 + x.values^7
} else {
print("Please choose appropriate polynomial order and type (or something else has goofed)")
break
}
output.list <- list(x.values = x.values, y.values = y.values, beta.true = beta.true)
return(output.list)
}
simulated.data <- GeneratePolyData(data.lower = -1, data.upper =  1, poly.order = 2, poly.type = 1, n.data.points = 50, sigma.noise = 0.1)
simulated.data\
simulated.data\
simulated.data
simulated.data$x.values
simulated.data[[1]]
setwd("/Users/hilary/Dropbox/BayesianMonPol/Code/Stan/")
help(MonoPoly)
??MonoPoly
library(MonoPoly)
??MonoPoly
help(MonoPoly)
install.packages("ggplot2")
library(ggplot2)
1.8^2 * 7
temp.sds <- c(1.8, 1.4, 1.7, 1.9)
temp.sdfs
temp.sds
temp.sds^2
temp.sds^2 * 7
sum(temp.sds^2 * 7)
sum(temp.sds^2 * 7) / 28
2.925 ^ 2
sum(temp.sds^2 * 24) / 28
sum(temp.sds^2 * 7) / 28
temp.sds
temp.ses <- temp.sds
temp.ses
temp.ses * sqrt(8)
(temp.ses * sqrt(8))^2
(temp.ses * sqrt(8))^2 * 7
sum((temp.ses * sqrt(8))^2 * 7)
sum((temp.ses * sqrt(8))^2 * 7) / (32 - 4 )
cbind(c(1,-1/2,-1/2), c(0,-1,1))
